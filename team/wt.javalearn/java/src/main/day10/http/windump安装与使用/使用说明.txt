安装使用,安装当前包下的驱动,然后吧WinDump.exe放到一个目录中,当前我放到了桌面

使用说明:
现在我们打开一个命令提示符，运行windump后出现：
C:\Users\Administrator\Desktop>windump
windump: listening on \Device\NPF_{2DD5168A-D7A1-4EC5-B760-F948E5D03517}
这表示windump正在监听我的网卡，网卡的设备名称是：
\Device\NPF_{2DD5168A-D7A1-4EC5-B760-F948E5D03517}
如果你看见屏幕上显示出这个信息，说明你的winpcap驱动已经正常安装，否则请下载并安装正确的驱动。

我们可以使用windump -h 查看windump的可用参数 和我们的版本
C:\Users\Administrator\Desktop>windump -h
windump version 3.9.5, based on tcpdump version 3.9.5
WinPcap version 4.1.3 (packet.dll version 4.1.0.2980), based on libpcap version
1.0 branch 1_0_rel0b (20091008)
Usage: windump [-aAdDeflLnNOpqRStuUvxX] [ -B size ] [-c count] [ -C file_size ]
                [ -E algo:secret ] [ -F file ] [ -i interface ] [ -M secret ]
                [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]
                [ -W filecount ] [ -y datalinktype ] [ -Z user ]
                [ expression ]

下面我来结合TCP的三步握手来介绍Windump的使用，请接着往下看：

C:\Users\Administrator\Desktop>windump -n
windump: listening on \Device\NPF_{2DD5168A-D7A1-4EC5-B760-F948E5D03517}

20:52:30.495329 IP 192.168.200.121.5353 > 224.0.0.251.5353:  0*- [0q] 4/0/4[|dom
ain]

先看第一行。其中20:52:30.495329 表示时间；192.168.200.121为源IP地址，端口5353，其实就是我自己的那台电脑；224.0.0.251是目的地址，端口5353

然后我找了好多等待了一会儿就发现了三次握手的一些包


20:59:28.465696 IP 192.168.200.167.54586 > 64.233.189.102.443: S 4067413724:4067413724(0) win 8192 <mss 1460,nop,wscale 2,nop,nop,sackOK>

20:59:29.030394 IP 64.233.189.102.443 > 192.168.200.167.54586: S 2733950406:2733950406(0) ack 4067413725 win 8760 <nop,nop,sackOK,mss 1460>

20:59:29.030394 IP 192.168.200.167.54586 > 64.233.189.102.443: . ack 1 win 8192

首先看第一行,有一个大S 4067413724:4067413724(0)表示我的电脑主动发起了一个SYN请求，这是第一步握手，4067413724是请求端的初始序列号 win 8192 表示发端通告的窗口大小；mss 1460表示由发端指明的最大报文段长度
这一行的意思就是我向64.233.189.102服务器发起一个tcp连接

第二行 源IP地址为192.168.0.10，而目的IP地址变为192.168.0.226

接下来我们看第二行，时间不说了；源IP地址为64.233.189.102.443，而目的IP地址变为192.168.200.167.54586；后面是
S 2733950406:2733950406(0) ack 912144277，这是第二步握手，2733950406是服务器端所给的初始序列号，ack 4067413725是确认序号，
是对第一行中客户端发起请求的初始序列号加1。该行表示服务器端接受客户端发起的TCP连接请求，并发出自己的初始序列号。

再看第三行，这是三步握手的最后一步，客户端发送ack 1，表示三步握手已经正常结束，下面就可以传送数据了。

以上就是tcp三次握手, 那么如果不成功呢 试用一下telnet功能, 安装telnet参考:https://jingyan.baidu.com/article/ae97a646b22fb6bbfd461d19.html     https://blog.csdn.net/ruuning_1940/article/details/79176319

这个时候我们再看windump所抓获的数据包：

D:/tools>windump -n

windump: listening on /Device/NPF_{3B4C19BE-6A7E-4A20-9518-F7CA659886F3}

10:38:22.006930 arp who-has 192.168.0.10 tell 192.168.0.226//第三行

10:38:22.007150 arp reply 192.168.0.10 is-at 0:60:8:92:e2:d//第四行

10:38:22.007158 IP 192.168.0.226.3324 > 192.168.0.10.23: S 1898244210:1898244210

(0) win 64240 <mss 1460,nop,nop,sackOK> (DF)

//第五行

10:38:22.007344 IP 192.168.0.10.23 > 192.168.0.226.3324: R 0:0(0) ack 1898244211 win 0

//第六行

10:38:22.478431 IP 192.168.0.226.3324 > 192.168.0.10.23: S 1898244210:1898244210(0) win 64240 <mss 1460,nop,nop,sackOK> (DF)

10:38:22.478654 IP 192.168.0.10.23 > 192.168.0.226.3324: R 0:0(0) ack 1 win 0

10:38:22.979156 IP 192.168.0.226.3324 > 192.168.0.10.23: S 1898244210:1898244210

(0) win 64240 <mss 1460,nop,nop,sackOK> (DF)

10:38:22.979380 IP 192.168.0.10.23 > 192.168.0.226.3324: R 0:0(0) ack 1 win 0

从第三行中，我们可以看见192.168.0.226因为不知道192.168.0.10的MAC地址，所以首先发送ARP广播包；在第四行中，192.168.0.10回应192.168.0.226的请求，告诉192.168.0.226它的MAC地址是0:60:8:92:e2:d。

第五行中，192.168.0.226向192.168.0.10发起SYN请求，但在第六行中，我们可以看见，因为目标主机拒绝了这一请求，故发送R 0:0(0)的响应，表示不接受192.168.0.226的请求。在接下来的几行中我们看见192.168.0.226连续向192.168.0.10发送SYN请求，但都被目标主机拒绝。

好了，写了这么多不知道大家看累了没有，如果累了，说明你还需要了解更多的TCP/IP知识，只有深入了解TCP/IP才有可能成为一个合格的网络管理员。Windump的参数很多，功能也非常强大，以上我所介绍的仅仅是它冰山的一角，希望能起到抛砖引玉的作用，也希望有更多的网络管理员能关注协议分析，只有这样，我们才能在日常的网络管理和应急时期的入侵分析中立于不败之地，为我们的网络安全做出贡献。

-a 将网络和广播地址转化为名称
-c 接收指定数据包后退出
-d 接收人可读的包匹配编译代码到标准输出，然后停止
-dd 以C程序分段方式捕获包匹配代码
-ddd 以十进制数据形式捕获包匹配代码
-e 在每个捕获行打印链路层头标
-E algo:secret为解密IPSE ESP包使用算法。
算法可以是des-cbc, 3des-cbc, blowfish-cbc, rc3-cbc, cast128-cbc, 或none。
默认值是desc-cbc。只有当TCPDUMP编译时使用激活加密选项时，才可以解密数据包。
Secret是ESP密匙是ASCII码。当前还不能认为一定是二进制值。该选项是以RFC2406ESP为假设，而不是RFC1827 ESP。只用于调试，不鼓励用真正的密码作为选项。当你在PS或其他场合，把IPSEC密码写在命令行上时，会被他人看到。
-f 不用符号而用数字方式输出外部英特网地址 -F 使用文件作为过滤表达式的输入。命令行的其他部分会被忽略。
-i 在接口上监听。如果没有指定，TCPDUMP将搜索系统接口列表中最小，被配置激活的接口（LOOPBACK接口除外）。可用最先匹配替换这种关系。在 WINDOWS中接口可以是网卡的名称，或是网卡的号码（-D参数可显示该号码）。内核为2。2或其后的LINUX系统，参数“ANY”可以获取所有接口 的数据。应注意的是在混乱模式下不能使用“ANY”参数。
-l 标准输出行缓存。如果你想在捕获数据时查看的话，这个参数很有用。
例如：“tcpdump -l │ tee dat” or “tcpdump -l > dat & tail -f dat”.” n 不要将地址（如主机地址，端口号）转换为名称 -N 不要打印主机名称的域名限定。如：如果你使用该参数，TCPDUMP会输出“NIC”而不是“NIC。DDN。MIL”。
-m 从文件模块中载入SMI MIB 模块定义。这个选项可以为TCPDUMP载入多个MIB模块
-O 不要运行包匹配代码优化器。只有在你怀疑优化器有问题时可以使用这个参数。
-p 不要让接口处于“混乱”模式。注意接口可能由于其他原因处于“混乱”模式；因此“-p”不能用作以太网络主机或广播的缩写。
-q 快速（安静？）输出。打印较少的协议信息，因此输出行更短。
-r 从文件中读取包（与参数据-W一起使用）。如果文件是“-”就使用标准输入。
-s 不使用默认的68个字节，更改从每个包中获取数据的字节数量（ SunOS系统实际最小为96）。对于IP，ICMP，TCP和UDP包68个字节已足够，但是对命名服务和NFS包，他们的协议会被截断（见下面）。包 被截断是因为在使用参数“[│proto]”输出时指定受限制的快照，proto是被截断协议层的名称。注意如果使用大的快照会增加处理包的时间，并且明 显地减少包的缓存数量。也许会导致包的丢失。你应该将snaplen 设置成你感兴趣协议的最小数。当snaplen 为0时接收整个包。
-T 根据表达式将选中的数据包表达成指定的类型。当前已有的类型有CNFP（Cisco的网络流量协议），rpc（远端程序调用），rtp（实时程序协议）， rtcp（实时程序控制协议），snmp（简单网络管理协议），vat（可视单频工具），和wb（分布式白板）。 -R 假设ESP/AH包遵守旧的说明（RFC1825到RFC1829）。如果该参数被指定，TCPDUMP不打输出域。因为在ESP/AH说明中没有协议版 本，TCPDUMP就无法推断出其版本号。 -S 输出绝对TCP序列号，而不是相对号。
-t 每个捕获行不要显示时间戳。 -tt 每个捕获行显示非格式化的时间时间戳。
-v 详细输出。例如，显示生存时间TTL，标识符，总长度和IP数据包的选项。也进行额外的包完整性较验，如验证IP和ICMP的头标较验值。
-vv 更为详细的输出。例如，显示NFS中继包中的其他域。
-vvv 很详细的输出。如，完全输出TELNET SB… SE选项。带-X参数的TELNET，打印并以十六进制输出。
-w 不对原始数据包解析打印而是转到文件中去。以后可用-r选项打印。当文件名为“-”表示标准输出。 -x 以十六进制（去除链路层头标）输出每个数据包。输出整个包的小部分或snaplen 个字节。
-X 输出十六进制同时，输出ASCII码。如果-x也被设置，数据包会以十六制/ASCII码显示。这对于分析新协议非常方便。如果-x也没有设置，一些数据包的部分会以十六制/ASCII码显示。 Win32特殊扩展
-B 以千字节为单位设置驱动缓存。默认缓存为1M（即1000）。如果在获取数据包时有数据丢失，建议使用该参数增大核心缓存大小，因为驱动缓存大小对数据捕获性能有很大影响。
-D 显示系统上可用的网卡列表。该参数将返回每块网卡的号码，名称和描述。
